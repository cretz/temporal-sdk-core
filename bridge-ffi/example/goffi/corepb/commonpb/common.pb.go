// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

package coresdk_common

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type WorkflowIdReusePolicy int32

const (
	WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED WorkflowIdReusePolicy = 0
	// Allow start a workflow execution using the same workflow Id, when workflow not running.
	WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE WorkflowIdReusePolicy = 1
	// Allow start a workflow execution using the same workflow Id, when workflow not running, and the last execution close state is in
	// [terminated, cancelled, timed out, failed].
	WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY WorkflowIdReusePolicy = 2
	// Do not allow start a workflow execution using the same workflow Id at all.
	WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE WorkflowIdReusePolicy = 3
)

var WorkflowIdReusePolicy_name = map[int32]string{
	0: "Unspecified",
	1: "AllowDuplicate",
	2: "AllowDuplicateFailedOnly",
	3: "RejectDuplicate",
}

var WorkflowIdReusePolicy_value = map[string]int32{
	"Unspecified":              0,
	"AllowDuplicate":           1,
	"AllowDuplicateFailedOnly": 2,
	"RejectDuplicate":          3,
}

func (WorkflowIdReusePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{0}
}

//* Possible causes of failure to cancel an external workflow
type CancelExternalWorkflowExecutionFailedCause int32

const (
	CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED                           CancelExternalWorkflowExecutionFailedCause = 0
	CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND CancelExternalWorkflowExecutionFailedCause = 1
)

var CancelExternalWorkflowExecutionFailedCause_name = map[int32]string{
	0: "Unspecified",
	1: "ExternalWorkflowExecutionNotFound",
}

var CancelExternalWorkflowExecutionFailedCause_value = map[string]int32{
	"Unspecified":                       0,
	"ExternalWorkflowExecutionNotFound": 1,
}

func (CancelExternalWorkflowExecutionFailedCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{1}
}

//* Possible causes of failure to signal an external workflow
type SignalExternalWorkflowExecutionFailedCause int32

const (
	SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED                           SignalExternalWorkflowExecutionFailedCause = 0
	SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND SignalExternalWorkflowExecutionFailedCause = 1
)

var SignalExternalWorkflowExecutionFailedCause_name = map[int32]string{
	0: "Unspecified",
	1: "ExternalWorkflowExecutionNotFound",
}

var SignalExternalWorkflowExecutionFailedCause_value = map[string]int32{
	"Unspecified":                       0,
	"ExternalWorkflowExecutionNotFound": 1,
}

func (SignalExternalWorkflowExecutionFailedCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{2}
}

// Used as arguments to activities, signals, queries, etc.
type Payload struct {
	Metadata map[string][]byte `protobuf:"bytes,1,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Data     []byte            `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Payload) Reset()      { *m = Payload{} }
func (*Payload) ProtoMessage() {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{0}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetMetadata() map[string][]byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Identifying information about a particular workflow execution. Namespace is expected to be
// assumed or included in whatever message is wrapping this one.
type WorkflowExecution struct {
	// Can never be empty
	WorkflowId string `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	// May be empty if the most recent run of the workflow with the given ID is being targeted
	RunId string `protobuf:"bytes,2,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
}

func (m *WorkflowExecution) Reset()      { *m = WorkflowExecution{} }
func (*WorkflowExecution) ProtoMessage() {}
func (*WorkflowExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{1}
}
func (m *WorkflowExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowExecution.Merge(m, src)
}
func (m *WorkflowExecution) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowExecution.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowExecution proto.InternalMessageInfo

func (m *WorkflowExecution) GetWorkflowId() string {
	if m != nil {
		return m.WorkflowId
	}
	return ""
}

func (m *WorkflowExecution) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

// Identifying information about a particular workflow execution, including namespace
type NamespacedWorkflowExecution struct {
	// Namespace the workflow run is located in
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Can never be empty
	WorkflowId string `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	// May be empty if the most recent run of the workflow with the given ID is being targeted
	RunId string `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
}

func (m *NamespacedWorkflowExecution) Reset()      { *m = NamespacedWorkflowExecution{} }
func (*NamespacedWorkflowExecution) ProtoMessage() {}
func (*NamespacedWorkflowExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{2}
}
func (m *NamespacedWorkflowExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespacedWorkflowExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespacedWorkflowExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespacedWorkflowExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespacedWorkflowExecution.Merge(m, src)
}
func (m *NamespacedWorkflowExecution) XXX_Size() int {
	return m.Size()
}
func (m *NamespacedWorkflowExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespacedWorkflowExecution.DiscardUnknown(m)
}

var xxx_messageInfo_NamespacedWorkflowExecution proto.InternalMessageInfo

func (m *NamespacedWorkflowExecution) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NamespacedWorkflowExecution) GetWorkflowId() string {
	if m != nil {
		return m.WorkflowId
	}
	return ""
}

func (m *NamespacedWorkflowExecution) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

// Defines how an activity or workflow should be retried in the event of failure, timeout, etc.
// Defaults may differ depending on what this is being used for. See containing messages.
type RetryPolicy struct {
	// Interval of the first retry. If backoff_coefficient is 1.0 then it is used for all
	// retries. If this is not specified, there will be *no retrying*. Lang SDKs should require
	// this to be set.
	InitialInterval *types.Duration `protobuf:"bytes,1,opt,name=initial_interval,json=initialInterval,proto3" json:"initial_interval,omitempty"`
	// Coefficient used to calculate the next retry interval. The next retry interval is previous
	// interval multiplied by the coefficient. Must be 1 or larger.
	BackoffCoefficient float64 `protobuf:"fixed64,2,opt,name=backoff_coefficient,json=backoffCoefficient,proto3" json:"backoff_coefficient,omitempty"`
	// Maximum interval between retries. Exponential backoff leads to interval increase. This value
	// caps that interval.
	MaximumInterval *types.Duration `protobuf:"bytes,3,opt,name=maximum_interval,json=maximumInterval,proto3" json:"maximum_interval,omitempty"`
	// Maximum number of attempts. When exceeded, retrying will stop. 1 disables retries. 0 means
	// unlimited retries (until the activity or workflow's total timeout is reached).
	MaximumAttempts int32 `protobuf:"varint,4,opt,name=maximum_attempts,json=maximumAttempts,proto3" json:"maximum_attempts,omitempty"`
	// If a stringified error type matches something in this list, retries will cease.
	NonRetryableErrorTypes []string `protobuf:"bytes,5,rep,name=non_retryable_error_types,json=nonRetryableErrorTypes,proto3" json:"non_retryable_error_types,omitempty"`
}

func (m *RetryPolicy) Reset()      { *m = RetryPolicy{} }
func (*RetryPolicy) ProtoMessage() {}
func (*RetryPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{3}
}
func (m *RetryPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicy.Merge(m, src)
}
func (m *RetryPolicy) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicy proto.InternalMessageInfo

func (m *RetryPolicy) GetInitialInterval() *types.Duration {
	if m != nil {
		return m.InitialInterval
	}
	return nil
}

func (m *RetryPolicy) GetBackoffCoefficient() float64 {
	if m != nil {
		return m.BackoffCoefficient
	}
	return 0
}

func (m *RetryPolicy) GetMaximumInterval() *types.Duration {
	if m != nil {
		return m.MaximumInterval
	}
	return nil
}

func (m *RetryPolicy) GetMaximumAttempts() int32 {
	if m != nil {
		return m.MaximumAttempts
	}
	return 0
}

func (m *RetryPolicy) GetNonRetryableErrorTypes() []string {
	if m != nil {
		return m.NonRetryableErrorTypes
	}
	return nil
}

func init() {
	proto.RegisterEnum("coresdk.common.WorkflowIdReusePolicy", WorkflowIdReusePolicy_name, WorkflowIdReusePolicy_value)
	proto.RegisterEnum("coresdk.common.CancelExternalWorkflowExecutionFailedCause", CancelExternalWorkflowExecutionFailedCause_name, CancelExternalWorkflowExecutionFailedCause_value)
	proto.RegisterEnum("coresdk.common.SignalExternalWorkflowExecutionFailedCause", SignalExternalWorkflowExecutionFailedCause_name, SignalExternalWorkflowExecutionFailedCause_value)
	proto.RegisterType((*Payload)(nil), "coresdk.common.Payload")
	proto.RegisterMapType((map[string][]byte)(nil), "coresdk.common.Payload.MetadataEntry")
	proto.RegisterType((*WorkflowExecution)(nil), "coresdk.common.WorkflowExecution")
	proto.RegisterType((*NamespacedWorkflowExecution)(nil), "coresdk.common.NamespacedWorkflowExecution")
	proto.RegisterType((*RetryPolicy)(nil), "coresdk.common.RetryPolicy")
}

func init() { proto.RegisterFile("common.proto", fileDescriptor_555bd8c177793206) }

var fileDescriptor_555bd8c177793206 = []byte{
	// 683 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x53, 0xcf, 0x4e, 0xdb, 0x48,
	0x18, 0xcf, 0x24, 0x84, 0x5d, 0x26, 0xec, 0x6e, 0x76, 0x5a, 0xaa, 0x40, 0x2b, 0x37, 0x42, 0xad,
	0x14, 0x50, 0x6b, 0x24, 0xca, 0x81, 0x96, 0x43, 0xe5, 0x3a, 0x93, 0xca, 0xc5, 0x75, 0x22, 0x27,
	0x51, 0xe0, 0x34, 0x9a, 0xd8, 0x13, 0x64, 0xc5, 0x9e, 0x89, 0x1c, 0x1b, 0xc8, 0xad, 0x8f, 0xd0,
	0x17, 0xe8, 0xbd, 0xc7, 0x3e, 0x06, 0x47, 0x8e, 0x1c, 0x8b, 0xb9, 0xf4, 0xc8, 0x23, 0x54, 0x36,
	0x4e, 0x02, 0x45, 0x50, 0xe8, 0x6d, 0xf2, 0xfb, 0x3b, 0xdf, 0x7c, 0x31, 0x9c, 0xb7, 0x84, 0xe7,
	0x09, 0x2e, 0x0f, 0x7c, 0x11, 0x08, 0xf4, 0xaf, 0x25, 0x7c, 0x36, 0xb4, 0xfb, 0xf2, 0x05, 0xba,
	0x24, 0xed, 0x09, 0xb1, 0xe7, 0xb2, 0xb5, 0x84, 0xed, 0x86, 0xbd, 0x35, 0x3b, 0xf4, 0x69, 0xe0,
	0x8c, 0xf5, 0xcb, 0x5f, 0x00, 0xfc, 0xab, 0x41, 0x47, 0xae, 0xa0, 0x36, 0x52, 0xe0, 0xdf, 0x1e,
	0x0b, 0xa8, 0x4d, 0x03, 0x5a, 0x02, 0xe5, 0x5c, 0xa5, 0xb0, 0xfe, 0x5c, 0xbe, 0x1a, 0x27, 0xa7,
	0x52, 0xf9, 0x63, 0xaa, 0xc3, 0x3c, 0xf0, 0x47, 0xe6, 0xc4, 0x86, 0x10, 0x9c, 0x49, 0xec, 0xd9,
	0x32, 0xa8, 0xcc, 0x9b, 0xc9, 0x79, 0x69, 0x0b, 0xfe, 0x73, 0x45, 0x8e, 0x8a, 0x30, 0xd7, 0x67,
	0xa3, 0x12, 0x28, 0x83, 0xca, 0x9c, 0x19, 0x1f, 0xd1, 0x43, 0x98, 0xdf, 0xa7, 0x6e, 0xc8, 0x52,
	0xdf, 0xc5, 0x8f, 0x37, 0xd9, 0x4d, 0xb0, 0xbc, 0x0d, 0xff, 0xef, 0x08, 0xbf, 0xdf, 0x73, 0xc5,
	0x01, 0x3e, 0x64, 0x56, 0x18, 0x5f, 0x1d, 0x3d, 0x85, 0x85, 0x83, 0x14, 0x24, 0x8e, 0x9d, 0x06,
	0xc1, 0x31, 0xa4, 0xd9, 0x68, 0x01, 0xce, 0xfa, 0x21, 0x8f, 0xb9, 0x6c, 0xc2, 0xe5, 0xfd, 0x90,
	0x6b, 0xf6, 0xf2, 0x10, 0x3e, 0x36, 0xa8, 0xc7, 0x86, 0x03, 0x6a, 0x31, 0xfb, 0x7a, 0xec, 0x13,
	0x38, 0xc7, 0xc7, 0x74, 0x1a, 0x3a, 0x05, 0x7e, 0x2d, 0xcd, 0xde, 0x52, 0x9a, 0xbb, 0x5c, 0xfa,
	0x2d, 0x0b, 0x0b, 0x26, 0x0b, 0xfc, 0x51, 0x43, 0xb8, 0x8e, 0x35, 0x42, 0x55, 0x58, 0x74, 0xb8,
	0x13, 0x38, 0xd4, 0x25, 0x0e, 0x0f, 0x98, 0xbf, 0x4f, 0xdd, 0xa4, 0xac, 0xb0, 0xbe, 0x28, 0x5f,
	0x2c, 0x4b, 0x1e, 0x2f, 0x4b, 0xae, 0xa6, 0xcb, 0x32, 0xff, 0x4b, 0x2d, 0x5a, 0xea, 0x40, 0x6b,
	0xf0, 0x41, 0x97, 0x5a, 0x7d, 0xd1, 0xeb, 0x11, 0x4b, 0xb0, 0x5e, 0xcf, 0xb1, 0x1c, 0xc6, 0x83,
	0xe4, 0x56, 0xc0, 0x44, 0x29, 0xa5, 0x4e, 0x99, 0xb8, 0xd6, 0xa3, 0x87, 0x8e, 0x17, 0x7a, 0xd3,
	0xda, 0xdc, 0x6f, 0x6b, 0x53, 0xcb, 0xa4, 0x76, 0x65, 0x9a, 0x42, 0x83, 0x80, 0x79, 0x83, 0x60,
	0x58, 0x9a, 0x29, 0x83, 0x4a, 0x7e, 0x22, 0x55, 0x52, 0x18, 0xbd, 0x86, 0x8b, 0x5c, 0x70, 0xe2,
	0xc7, 0xa3, 0xd3, 0xae, 0xcb, 0x08, 0xf3, 0x7d, 0xe1, 0x93, 0x60, 0x34, 0x60, 0xc3, 0x52, 0xbe,
	0x9c, 0xab, 0xcc, 0x99, 0x8f, 0xb8, 0xe0, 0xe6, 0x98, 0xc7, 0x31, 0xdd, 0x8a, 0xd9, 0xd5, 0x13,
	0x00, 0x17, 0x3a, 0x93, 0x87, 0x35, 0x59, 0x38, 0x64, 0xe9, 0xe3, 0x55, 0xe0, 0xb3, 0x4e, 0xdd,
	0xdc, 0xae, 0xe9, 0xf5, 0x0e, 0xd1, 0xaa, 0xc4, 0xc4, 0xed, 0x26, 0x26, 0x8d, 0xba, 0xae, 0xa9,
	0xbb, 0xa4, 0x6d, 0x34, 0x1b, 0x58, 0xd5, 0x6a, 0x1a, 0xae, 0x16, 0x33, 0xe8, 0x05, 0xac, 0xdc,
	0xa8, 0x54, 0xf4, 0x18, 0xad, 0xb6, 0x1b, 0xba, 0xa6, 0x2a, 0x2d, 0x5c, 0x04, 0x68, 0x13, 0x6e,
	0xdc, 0x55, 0x4d, 0x6a, 0x8a, 0xa6, 0xe3, 0x2a, 0xa9, 0x1b, 0xfa, 0x6e, 0x31, 0x8b, 0x5e, 0xc2,
	0x95, 0x1b, 0x9d, 0x26, 0xfe, 0x80, 0xd5, 0xd6, 0xa5, 0xa2, 0xdc, 0xea, 0x11, 0x80, 0xab, 0x2a,
	0xe5, 0x16, 0x73, 0xf1, 0x61, 0xc0, 0x7c, 0x4e, 0xdd, 0x6b, 0xff, 0xc3, 0x1a, 0x75, 0x5c, 0x66,
	0xab, 0x34, 0x1c, 0x32, 0xf4, 0x16, 0x6e, 0xa9, 0x8a, 0xa1, 0x62, 0x9d, 0xe0, 0x9d, 0x16, 0x36,
	0x0d, 0x45, 0x27, 0x93, 0x36, 0xbc, 0x83, 0xd5, 0x76, 0x4b, 0xab, 0x1b, 0xe3, 0x1b, 0xa9, 0x4a,
	0xdc, 0x7d, 0xf5, 0x19, 0x76, 0x61, 0xfb, 0xbe, 0x01, 0xb7, 0x09, 0x8d, 0x7a, 0x8b, 0xd4, 0xea,
	0x6d, 0xa3, 0x5a, 0x04, 0xc9, 0x28, 0x4d, 0x67, 0x8f, 0xd3, 0x3b, 0x8f, 0xd2, 0xd4, 0xde, 0xc7,
	0xb9, 0x7f, 0x3e, 0xca, 0x7d, 0x03, 0xee, 0x38, 0xca, 0xbb, 0x8d, 0xe3, 0x53, 0x29, 0x73, 0x72,
	0x2a, 0x65, 0xce, 0x4f, 0x25, 0xf0, 0x29, 0x92, 0xc0, 0xd7, 0x48, 0x02, 0x47, 0x91, 0x04, 0x8e,
	0x23, 0x09, 0x7c, 0x8f, 0x24, 0xf0, 0x23, 0x92, 0x32, 0xe7, 0x91, 0x04, 0x3e, 0x9f, 0x49, 0x99,
	0xe3, 0x33, 0x29, 0x73, 0x72, 0x26, 0x65, 0xba, 0xb3, 0xc9, 0x07, 0xf3, 0xea, 0x67, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x3e, 0x94, 0x5b, 0xdf, 0x82, 0x05, 0x00, 0x00,
}

func (x WorkflowIdReusePolicy) String() string {
	s, ok := WorkflowIdReusePolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CancelExternalWorkflowExecutionFailedCause) String() string {
	s, ok := CancelExternalWorkflowExecutionFailedCause_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SignalExternalWorkflowExecutionFailedCause) String() string {
	s, ok := SignalExternalWorkflowExecutionFailedCause_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Payload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Payload)
	if !ok {
		that2, ok := that.(Payload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if !bytes.Equal(this.Metadata[i], that1.Metadata[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *WorkflowExecution) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WorkflowExecution)
	if !ok {
		that2, ok := that.(WorkflowExecution)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WorkflowId != that1.WorkflowId {
		return false
	}
	if this.RunId != that1.RunId {
		return false
	}
	return true
}
func (this *NamespacedWorkflowExecution) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespacedWorkflowExecution)
	if !ok {
		that2, ok := that.(NamespacedWorkflowExecution)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.WorkflowId != that1.WorkflowId {
		return false
	}
	if this.RunId != that1.RunId {
		return false
	}
	return true
}
func (this *RetryPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryPolicy)
	if !ok {
		that2, ok := that.(RetryPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InitialInterval.Equal(that1.InitialInterval) {
		return false
	}
	if this.BackoffCoefficient != that1.BackoffCoefficient {
		return false
	}
	if !this.MaximumInterval.Equal(that1.MaximumInterval) {
		return false
	}
	if this.MaximumAttempts != that1.MaximumAttempts {
		return false
	}
	if len(this.NonRetryableErrorTypes) != len(that1.NonRetryableErrorTypes) {
		return false
	}
	for i := range this.NonRetryableErrorTypes {
		if this.NonRetryableErrorTypes[i] != that1.NonRetryableErrorTypes[i] {
			return false
		}
	}
	return true
}
func (this *Payload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&coresdk_common.Payload{")
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string][]byte{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WorkflowExecution) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&coresdk_common.WorkflowExecution{")
	s = append(s, "WorkflowId: "+fmt.Sprintf("%#v", this.WorkflowId)+",\n")
	s = append(s, "RunId: "+fmt.Sprintf("%#v", this.RunId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespacedWorkflowExecution) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&coresdk_common.NamespacedWorkflowExecution{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "WorkflowId: "+fmt.Sprintf("%#v", this.WorkflowId)+",\n")
	s = append(s, "RunId: "+fmt.Sprintf("%#v", this.RunId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RetryPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&coresdk_common.RetryPolicy{")
	if this.InitialInterval != nil {
		s = append(s, "InitialInterval: "+fmt.Sprintf("%#v", this.InitialInterval)+",\n")
	}
	s = append(s, "BackoffCoefficient: "+fmt.Sprintf("%#v", this.BackoffCoefficient)+",\n")
	if this.MaximumInterval != nil {
		s = append(s, "MaximumInterval: "+fmt.Sprintf("%#v", this.MaximumInterval)+",\n")
	}
	s = append(s, "MaximumAttempts: "+fmt.Sprintf("%#v", this.MaximumAttempts)+",\n")
	s = append(s, "NonRetryableErrorTypes: "+fmt.Sprintf("%#v", this.NonRetryableErrorTypes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCommon(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCommon(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCommon(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WorkflowId) > 0 {
		i -= len(m.WorkflowId)
		copy(dAtA[i:], m.WorkflowId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.WorkflowId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespacedWorkflowExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespacedWorkflowExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespacedWorkflowExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.WorkflowId) > 0 {
		i -= len(m.WorkflowId)
		copy(dAtA[i:], m.WorkflowId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.WorkflowId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NonRetryableErrorTypes) > 0 {
		for iNdEx := len(m.NonRetryableErrorTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NonRetryableErrorTypes[iNdEx])
			copy(dAtA[i:], m.NonRetryableErrorTypes[iNdEx])
			i = encodeVarintCommon(dAtA, i, uint64(len(m.NonRetryableErrorTypes[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaximumAttempts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaximumAttempts))
		i--
		dAtA[i] = 0x20
	}
	if m.MaximumInterval != nil {
		{
			size, err := m.MaximumInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BackoffCoefficient != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BackoffCoefficient))))
		i--
		dAtA[i] = 0x11
	}
	if m.InitialInterval != nil {
		{
			size, err := m.InitialInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCommon(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCommon(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *WorkflowExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkflowId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *NamespacedWorkflowExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.WorkflowId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *RetryPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitialInterval != nil {
		l = m.InitialInterval.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.BackoffCoefficient != 0 {
		n += 9
	}
	if m.MaximumInterval != nil {
		l = m.MaximumInterval.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.MaximumAttempts != 0 {
		n += 1 + sovCommon(uint64(m.MaximumAttempts))
	}
	if len(m.NonRetryableErrorTypes) > 0 {
		for _, s := range m.NonRetryableErrorTypes {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Payload) String() string {
	if this == nil {
		return "nil"
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string][]byte{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%v: %v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	s := strings.Join([]string{`&Payload{`,
		`Metadata:` + mapStringForMetadata + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkflowExecution) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WorkflowExecution{`,
		`WorkflowId:` + fmt.Sprintf("%v", this.WorkflowId) + `,`,
		`RunId:` + fmt.Sprintf("%v", this.RunId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespacedWorkflowExecution) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespacedWorkflowExecution{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`WorkflowId:` + fmt.Sprintf("%v", this.WorkflowId) + `,`,
		`RunId:` + fmt.Sprintf("%v", this.RunId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetryPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RetryPolicy{`,
		`InitialInterval:` + strings.Replace(fmt.Sprintf("%v", this.InitialInterval), "Duration", "types.Duration", 1) + `,`,
		`BackoffCoefficient:` + fmt.Sprintf("%v", this.BackoffCoefficient) + `,`,
		`MaximumInterval:` + strings.Replace(fmt.Sprintf("%v", this.MaximumInterval), "Duration", "types.Duration", 1) + `,`,
		`MaximumAttempts:` + fmt.Sprintf("%v", this.MaximumAttempts) + `,`,
		`NonRetryableErrorTypes:` + fmt.Sprintf("%v", this.NonRetryableErrorTypes) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCommon(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCommon
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkflowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespacedWorkflowExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespacedWorkflowExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespacedWorkflowExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkflowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitialInterval == nil {
				m.InitialInterval = &types.Duration{}
			}
			if err := m.InitialInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackoffCoefficient", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BackoffCoefficient = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaximumInterval == nil {
				m.MaximumInterval = &types.Duration{}
			}
			if err := m.MaximumInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumAttempts", wireType)
			}
			m.MaximumAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumAttempts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonRetryableErrorTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonRetryableErrorTypes = append(m.NonRetryableErrorTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
